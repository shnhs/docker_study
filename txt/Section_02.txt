==================================================================	
27. 이미지, 컨테이너 관리

docker 커맨드에 --help로 옵션을 볼 수 있음

태그달기(이미지 명명) / 이미지 나열 / 이미지 분석, 검사 / 이미지 삭제
컨테이너 이름 /  컨테이너 config / 
컨테이너 listen / 컨테이너 list / 컨테이너 삭제 / 제거

==================================================================
28. 컨테이너 중지, 재시작

이미지와 컨테이너 관리
docker ps 	 	실행중인 컨테이너 리스트업
docker ps -a    중지된 컨테이너, 과거의 컨테이너까지 리스트업

중지된 컨테이너 시작
docker run      이미지를 기반으로 새 컨테이너 생성

기존 컨테이너 시작
docker start [Id or Name]       기존의 컨테이너를 실행시킴

==================================================================
29. Attached & Detached

docker start    => Detached 모드가 디폴트
docker run      => Attached 모드가 디폴트. 실행중인 컨테이너에 연결됨

docker run -p port:port -d [Id]
    => -d 옵션으로 Detached 모드로 컨테이너 실행

Attached 모드로 실행 / docker attach [id]
    => 실행중인 컨테이너 터미널을 계속 보고 싶을때
   
docker logs [Id]
    => Detached 모드에서 컨테이너의 로그를 보고싶을때?

docker logs -f [Id] 
    => -f 옵션으로 로그를 계속 볼 수 있음
    
==================================================================
31. 인터렉티브 모드

웹 서버 기반의 무언가가 아니더라도 도커, 이미지화 가능

docker run [image] 
    => 기본적으로 디폴트로 컨테이너에 연결

docker run 옵션
-i  : 자동으로 인터렉티브모드로 연결
-t  : pseudo TTY 할당(터미널 생성을 의미?)

docker run -it [image]
    => Attached모드로 디폴트 실행
    
그러나 docker start로 하면 Detached모드로 디폴트 실행됨
얘는 어떻게 접근?

1. 중지했다가 -a 옵션으로 재시작
    근데 이러면 작동 후 한번만 입력가능해짐?

2. docker start -a -i 옵션으로 실행

==================================================================
32. 이미지, 컨테이너 삭제

docker rm
    => 컨테이너 제거. 단 실행중인 컨테이너는 중지부터 해야함
    
docker images
    => 모든 이미지 리스트업
    
docker rmi
    => 이미지 삭제. 해당 이미지로 만들어진 컨테이너가 존재하면 삭제 불가
    
docker image/container prune
    => 사용중이지 않는 이미지/컨테이너 전체 삭제

==================================================================
33. 중지된 컨테이너 자동 삭제

docker run --rm 옵션
    => 컨테이너 중지시 자동으로 제거되는 옵션

==================================================================
34. 이미지 검사

이미지는 용량이 꽤나 크다
실행 중인 컨테이너는 실제로는 그렇게 크지 않음
=> 명령레이어가 이미지 위에 추가된 얇은 부가 레이어

이미지는 잠겨있고, 읽기 전용 컨테이너만 변경 가능

docker image inspect [imageId]
=> 이미지의 대한 정보 출력

이미지의 전체아이디, 이미지의 생성 날짜 및 시간, 컨테이너 구성,
포트 노출, 환경변수, EntryPoint, 사용중인 운영체제

==================================================================
35. 컨테이너 파일 복사

컨테이너에 추가 혹은 컨테이너에서 추출 => cp

docker cp [source] [target]
컨테이너 내부를 지정할 때 포맷 : [container_name:/path]

컨테이너 재실행 없이 무언가를 추가할 수 있음 / 혹은 빼낼 수 있음
예를 들어 로그파일

==================================================================
36. 컨테이너 이미지 이름 지정, 태그 지정

이미지 혹은 컨테이너에 태그 지정

컨테이너 이름
docker run ~~ --name [name] ~~

이미지 이름 - NAME:TAG
두 부분으로 구분
이름(name; repository)
태그(tag)
왜? - 이름은 이미지 그룹을 지정하기 위함, 태그는 버전 정의

docker build -t [name:tag] ~

==================================================================
37. 이미지 공유

코드와 DockerFile을 같이 공유 => 직접 빌드해서 가능
빌드된 이미지를 공유해주면 그 이미지를 기반으로 컨테이너 실행 가능

==================================================================
38. DockerHub에 이미지 푸시(업로드)

이미지 업로드 => DockerHub or 개인 registry

이미지 태그를 다시 지정 => 이전 이미지의 복제본 생성하는거임
docker tag [old Name] [new Name]

==================================================================
39. Docker Pull

push는 로그인과 레포지토리가 필요하지만
pull은 누구나 할 수 있다.

==================================================================
40. 섹션2 요약

도커는 이미지와 컨테이너의 관한 모든것
=> 이미지는 템플릿, 컨테이너의 블루프린트

하나의 이미지를 기반으로 여러개의 컨테이너 실행 가능

컨테이너는 이미지 위에 작은 레이어로 효율적으로 존재
이미지에 저장된 코드와 환경에서 실행

이미지는 pull 해오거나 공유받거나 자체 빌드로 생성 가능

docker run 으로 이미지를 기반으로 하는 컨테이너 실행

==================================================================