===============================================================
2. 도커란

도커? - 컨테이너를 생성하고 관리하기 위한 도구

컨테이너? - 표준화된 SW 유닛, 코드패키지 + 해당 코드를 실행하는데 필요한 종속성

===============================================================
3. 

도커와 컨테이너 사용의 이점
- 코드의 실행 환경을 통일할 수 있다.
- 개발 환경을 통일할 수 있다.
- 프로젝트간 버전 관리를 용이하게 가능

===============================================================
5. VM vs Docker

버츄얼머신
=> (Host 머신, 시스템) | (Virtual OS) | (Libraries, Dependencies) | (APP)
    실제로 개별로 동작하는 하나의 컴퓨터로 생각하면 됨

Docker
=> (Host System) | (OS built Container Support) | (Docker Engine) | (Container)
    운영체제, 환경설정 등 거대한 부분 생략 가능

===============================================================
13.

*********************

[DockerFile]

FROM node:14    # Node14 베이스 이미지

WORKDIR /app    # 컨테이너 파일 시스템 경로

COPY package.json .

RUN npm install     # 필요한 모든 종속성 설치

COPY . .    # 다른 코드 복사

EXPOSE 3000     # 컨테이너 외부에서 수신할 포트 지정

CMD [ "node", "app.mjs" ]

*********************

===============================================================
18. 이미지와 컨테이너

컨테이너 - Unit of SW. 이미지의 구체적인 실행 인스턴트

이미지 - 컨테이너 설계도, 모든 설정명령과 모든 코드가 포함된 공유가능 패키지

이미지를 통해 컨테이너를 생성
하나의 이미지를 사용해서 여러 컨테이너 생성 가능

===============================================================
19. 외부 이미지 사용

docker run -it node
    => -it 옵션은 도커에게 컨테이너 내부에서 
        호스팅머신으로 대화형 세션을 노출하고자 하는 옵션

===============================================================
21. DockerFile로 자체 이미지 빌드

DockerFile - 도커에서 인식되는 특수한 이름

...

[DockerFile]

# base가 될 운영체제 이미지
FROM node

# 명령어들이 실행될 경로 지정
WORKDIR /app 

COPY package.json /app

# 필요한 명령어 입력
RUN npm install

# 앞은 컨테이너 외부 경로 - . 이라면 Dockerfile이 포함된 경로의 모든 하위 소스
# 뒤에는 컨테이너 내부 경로, ./ 라면 현재 작업경로로 지정
COPY . /app

# 특정 포트에 노출 세팅
EXPOSE 80

# 이미지 기반의 컨테이너가 생성될 때 마다 해당 명령어 실행 
CMD [ "node", "server.js" ]

...

===============================================================
22. 자체 이미지 실행

docker build [dockerFile 경로] - dockerFile에 따라 이미지 빌드

docker run -p [로컬포트]:[도커 포트] [imageId]
    => -p 옵션으로 포트노출

===============================================================
24. 

도커파일에서 사용할 수 있는 하위 명령어
이미지와 컨테이너가 작동하는 방식

코드를 수정한다고 해보자
실행중인 애플리케이션에 바로 적용하는데 아주 작은 변동사항

기존의 이미지를 다시 컨테이너에 올리면 변동사항 적용x

이미지는 만들어질 때 그 당시의 소스코드를 복사하여(스냅샷) 올린 상태
	=> 이후에 수정된 사항은 이미지내의 소스코드에 반영 안됨, 이미지는 읽기 전용!
	=> 코드 수정사항을 반영하려면 이미지를 다시 빌드해야함
	
===============================================================
25. 

이미지는 "레이어 기반"
=> 이미지를 빌드하거나 다시 빌드할 떄 변경된 부분의 명령과 그 이후의 코드가 재평가됨

한번 이미지를 빌드하고 이후에 코드의 수정없이 다시 빌드하게되면
	=> 빌드 속도 매우 빠름, using cache
	=> 일부만 변경할 경우 일부는 캐시 사용, 일부 명령어는 새로 실행

이런것을 "레이어 기반 아키텍쳐"

한 레이어가 다시 빌드되면 이후 명령어들은 새로 실행

ex)
...
copy . /app
run npm install
...

이런경우에  코드에 수정이 발생하면 무조건 copy명령어를 새로 실행
그렇다면 항상 이미지를 빌드할 때 npm install 실행 
	=> 사실 근데 npm install은 안바뀌니까 좀 불필요

도커 최적화 가능!
...
COPY package.json /app // 소스코드 복사전에 npm install
RUN npm install
COPY . /app
...

소스코드를 수정해도 npm install은 다시 실행되지 않음

==================================================================
26. 섹션1 요약

도커는 코드에 관한 모든것
이미지에 우리의 코드와 환경을 모두 넣자
도커파일에 어떤 환경과 코드를 넣을것인지 세팅한다
내부포트를 몇으로 노출할건지 설정한다
이미지는 컨테이너를 생성할 템플릿이다.
컨테이너는 이미지를 기반으로 실행되는 애플리케이션
하나의 이미지로 여러개의 컨테이너생성 가능

"앱을 포함하는 격리된 환경, 그 앱을 실행하는데 필요한 모든것, 모든 환경, 도구를
	컨테이너 안에 모두 포함시키는 것" => 도커
	
==================================================================	
27. 이미지, 컨테이너 관리

docker 커맨드에 --help로 옵션을 볼 수 있음

태그달기(이미지 명명) / 이미지 나열 / 이미지 분석, 검사 / 이미지 삭제
컨테이너 이름 /  컨테이너 config / 
컨테이너 listen / 컨테이너 list / 컨테이너 삭제 / 제거

==================================================================
28. 컨테이너 중지, 재시작

이미지와 컨테이너 관리
docker ps 	 	실행중인 컨테이너 리스트업
docker ps -a    중지된 컨테이너, 과거의 컨테이너까지 리스트업

중지된 컨테이너 시작
docker run      이미지를 기반으로 새 컨테이너 생성

기존 컨테이너 시작
docker start [Id or Name]       기존의 컨테이너를 실행시킴

==================================================================
29. Attached & Detached

docker start    => Detached 모드가 디폴트
docker run      => Attached 모드가 디폴트. 실행중인 컨테이너에 연결됨

docker run -p port:port -d [Id]
    => -d 옵션으로 Detached 모드로 컨테이너 실행

Attached 모드로 실행 / docker attach [id]
    => 실행중인 컨테이너 터미널을 계속 보고 싶을때
   
docker logs [Id]
    => Detached 모드에서 컨테이너의 로그를 보고싶을때?

docker logs -f [Id] 
    => -f 옵션으로 로그를 계속 볼 수 있음
    
==================================================================
31. 인터렉티브 모드

웹 서버 기반의 무언가가 아니더라도 도커, 이미지화 가능

docker run [image] 
    => 기본적으로 디폴트로 컨테이너에 연결

docker run 옵션
-i  : 자동으로 인터렉티브모드로 연결
-t  : pseudo TTY 할당(터미널 생성을 의미?)

docker run -it [image]
    => Attached모드로 디폴트 실행
    
그러나 docker start로 하면 Detached모드로 디폴트 실행됨
얘는 어떻게 접근?

1. 중지했다가 -a 옵션으로 재시작
    근데 이러면 작동 후 한번만 입력가능해짐?

2. docker start -a -i 옵션으로 실행

==================================================================
32. 이미지, 컨테이너 삭제

docker rm
    => 컨테이너 제거. 단 실행중인 컨테이너는 중지부터 해야함
    
docker images
    => 모든 이미지 리스트업
    
docker rmi
    => 이미지 삭제. 해당 이미지로 만들어진 컨테이너가 존재하면 삭제 불가
    
docker image/container prune
    => 사용중이지 않는 이미지/컨테이너 전체 삭제

==================================================================
33. 중지된 컨테이너 자동 삭제

docker run --rm 옵션
    => 컨테이너 중지시 자동으로 제거되는 옵션

==================================================================
34. 이미지 검사

이미지는 용량이 꽤나 크다
실행 중인 컨테이너는 실제로는 그렇게 크지 않음
=> 명령레이어가 이미지 위에 추가된 얇은 부가 레이어

이미지는 잠겨있고, 읽기 전용 컨테이너만 변경 가능

docker image inspect [imageId]
=> 이미지의 대한 정보 출력

이미지의 전체아이디, 이미지의 생성 날짜 및 시간, 컨테이너 구성,
포트 노출, 환경변수, EntryPoint, 사용중인 운영체제

==================================================================
35. 컨테이너 파일 복사

컨테이너에 추가 혹은 컨테이너에서 추출 => cp

docker cp [source] [target]
컨테이너 내부를 지정할 때 포맷 : [container_name:/path]

컨테이너 재실행 없이 무언가를 추가할 수 있음 / 혹은 빼낼 수 있음
예를 들어 로그파일

==================================================================
36. 컨테이너 이미지 이름 지정, 태그 지정

이미지 혹은 컨테이너에 태그 지정

컨테이너 이름
docker run ~~ --name [name] ~~

이미지 이름 - NAME:TAG
두 부분으로 구분
이름(name; repository)
태그(tag)
왜? - 이름은 이미지 그룹을 지정하기 위함, 태그는 버전 정의

docker build -t [name:tag] ~

==================================================================
37. 이미지 공유

코드와 DockerFile을 같이 공유 => 직접 빌드해서 가능
빌드된 이미지를 공유해주면 그 이미지를 기반으로 컨테이너 실행 가능

==================================================================
38. DockerHub에 이미지 푸시(업로드)

이미지 업로드 => DockerHub or 개인 registry

이미지 태그를 다시 지정 => 이전 이미지의 복제본 생성하는거임
docker tag [old Name] [new Name]

==================================================================
39. Docker Pull

push는 로그인과 레포지토리가 필요하지만
pull은 누구나 할 수 있다.

==================================================================
40. 섹션2 요약

도커는 이미지와 컨테이너의 관한 모든것
=> 이미지는 템플릿, 컨테이너의 블루프린트

하나의 이미지를 기반으로 여러개의 컨테이너 실행 가능

컨테이너는 이미지 위에 작은 레이어로 효율적으로 존재
이미지에 저장된 코드와 환경에서 실행

이미지는 pull 해오거나 공유받거나 자체 빌드로 생성 가능

docker run 으로 이미지를 기반으로 하는 컨테이너 실행

==================================================================
43. 데이터 카테고리

애플리케이션(소스코드 + 실행 환경) 
=> 개발 작성 코드 패키지 + 이미지에 있는 레이어; 빌드되면 데이터는 고정 

2개의 다른 데이터 카테고리

temp App Data
=> 앱 실행 동안 생성된 데이터 ex) 폼에 입력된 데이터
    일시적 데이터로 장기간 보관x
    이미지가 아닌 컨테이너에 저장
    컨테이너는 read-write 레이어
    
permanent App Data
=> 영구적으로 저장할 데이터, 지속 되어야 함
    컨테이너가 재실행 되더라도 지속되어야 함
    
영구 데이터는 read-write이지만 영구적으로 지속되야함
=> 볼륨 이라는 개념의 도움을 받아야 함

==================================================================
44. 실제 분석

temp에 임시 파일을 생성하고
feedback 폴더에 해당 파일이 존재하지 않으면 새 파일 생성

==================================================================
45. 데모 앱 구축

컨테이너에는 이미지를 기반으로 하는 자체 파일 시스템이 있음

따로 지정하지 않으면
컨테이너 파일 시스템 - 로컬 파일 시스템 사이 커넥션은 없음

==================================================================
46. 문제 이해

컨테이너를 삭제하게 되면 내부 파일은 삭제
단순히 중지 하고 재시작하면 read-write 레이어의 파일 시스템은 유지

container remove 는 데이터 완전 삭제됨

==================================================================
47. 볼륨

도커에는 볼륨이라는 내장기능 
=>데이터를 유지하도록 도움을 준다

일단 볼륨이 뭐냐 
=> 호스트 머신의 폴더(하드 드라이브), 도커 컨테이너 내부의 폴더에 매핑됨
    컨테이너 내부의 폴더를 호스트 머신의 외부 폴더와 연결
    서로 변경사항을 반영함
    볼륨을 통해 데이터 유지
    컨테이너가 제거되어도 볼륨은 유지
    컨테이너는 볼륨에 파일을 읽고 쓸수 있음
    
==================================================================
48. 

볼륨 추가 => 쉽게는 도커 파일에 명시하기?

***
VOLUME ["[컨테이너 파일시스템 내부의 경로]"]
***

==================================================================
49. 명명된 볼륨

도커의 외부 데이터 저장 메커니즘 => 볼륨, 마운트

두 타입의 볼륨

1. 익명 볼륨
VOLUME ["[컨테이너 파일시스템 내부의 경로]"]
=> 이미지에 익명 볼륨을 할당

2. 명명된 볼륨

두 경우 모두 도커가 일부 폴더와 경로를 호스트 머신에 설정

익명볼륨일경우
단 내가 모름. docker volume으로 볼 수 있음
docker volume ls
단 익명 볼륨이기 떄문에 컨테이너가 존재할때만 존재함
따라서 정확히 어디 있는 지 찾기 힘듬

명명 볼륨일 경우
컨테이너 종료 후에도 볼륨이 유지 -> 하드드라이브의 폴더가 유지
컨테이너 재시작하면 볼륨이 복구, 데이터도 복구
영구적인 데이터나 직접 볼 필요가 딱히 없는 데이터에 사용

명명 볼륨은 도커 파일이 아니라 컨테이너 실행 할 때 명시함
docker run ~~ -v [명명 볼륨 이름]:[볼륨과 연결할 컨테이너 내부 경로] ~~

==================================================================
50. 익명 볼륨 제거

--rm 옵션이 없으면 익명 볼륨이 자동으로 제거되지 않음

사용하지 않는 익명 볼륨 삭제
docker rm [volume_name]
docker volume prune

==================================================================
51. 바인드 마운트

호스트머신 상에 매핑될 컨테이너의 경로를 내가 설정
영구적이고 편집 가능한 데이터에 적합

명명 볼륨은 영구적인 저장은 가능하지만 호스트 머신에 어디 저장되는지 모름
마인드 마운트는 영구적인 저장도 가능하고 호스트 머신 어디 저장되는지도 암


==================================================================
52. 

바인드 마운트랑 익명 볼륨을 같이 사용
=> 두 볼륨을 따로 관리 할 수 있음

==================================================================
53. Nodemon 사용

특정 컨테이너의 웹 서버를 재시작 하기
=> 가장 쉬운 방법은 컨테이너 내렸다가 재시작하기

nodemon dependency 설정으로 파일 변경 감시자 사용

==================================================================
54. 볼륨, 바인드 마운트 요약

docker run -v /app/data                 => 익명 볼륨 생성
docker run -v data:/app/data            => data 라는 이름의 명명 볼륨 생성
docker run -v /path/to/code:/app/data   => 호스트 머신의 폴더를 가르키는 바인드 마운트

익명볼륨은 
- 컨테이너에 연결된 익명 볼륨 생성, 컨테이너가 지워지면 같이 삭제
--rm 옵션을 같이 사용하면 익명 볼륨 같이 삭제, 컨테이너 데이터 공유 불가
컨테이너에 이미 존재하는 데이터를 잠그는데 유용(다른 모듈에 의해 덮어쓰여지는 것 방지)
호스트 머신에 폴더를 생성하지만 어디있는지 모름

명명 볼륨은
- Dockerfile에서 생성 안함
-v 옵션으로 지정, 일반적으로 생성, 특정 컨테이너와 연결되는게 아님
컨테이너 삭제되어도 유지, 여러 컨테이너에서 데이터 사용 가능

바인드 마운트는
- 호스트 머신에 데이터가 저장되는 위치를 알고있음
다수의 컨테이너와 사용가능
컨테이너와 데이터 공유 가능

==================================================================
56. 읽기 전용 볼륨

기본적으로 볼륨은 read-write

컨테이너에서 바인드 마운트를 read-only로 변경 가능
[host/path]:[container/path]:ro
ro 옵션을 추가하면 도커가 그 폴더나 하위 폴더에 write불가능

==================================================================
57. Docker 볼륨 관리

docker volume ls    도커에 의해 관리되고 있는 volume 리스트를 보여줌

바인드 마운트는 ls에 안뜸 
바인드 마운트는 내가 알고있는 로컬 폴더를 컨테이너 내부와 바인딩

docker volume create [name]     도커 볼륨 직접 생성
docker volume inspect [volume]  해당 볼륨에 대한 정보 보기

==================================================================
58. COPY vs 바인드 마운트

COPY는 코드의 스냅샷을 가짐
프로덕션 환경에서는 코드의 스냅샷을 가지고 있는 이미지가 필요함

==================================================================
59. .dockerignore

앞에 .이 있음을 유의하자
gitignore와 유사함

COPY 명령으로 복사하지 않을 특정 내용 혹은 폴더을 지정

일반적으로 애플리케이션이 올바르게 실행되는데 필요없는 모든 것을 추가

==================================================================
61. 환경변수 .env 작업

인수(ARG), 환경변수(ENV)

도커는 빌드 타임 인수와 런타임 환경변수 지원

인수
dockerFile에서 특정 값을 추출하는데 사용할 수 있음

환경변수
dockerFile에서 사용, 전체 애플리케이션 코드에서 사용 가능

컨테이너나 이미지에서 하드코딩을 줄여줌

dockerFile에서 환경변수를 사용하려면
ENV [Key] [Value]
다른 구문에서 사용할 경우 $[Key]와 같은 형태로 사용

docker run ~~ --env [Key]=[value] ~~
docker run ~~ --e [Key]=[value] ~~
여러개의 환경변수 세팅 가능

따로 환경변수 파일로 만들 수 있음
--env-file [환경변수 파일 경로]

==================================================================
62. 빌드인수(ARG) 사용

빌드인수 ARG
dockerFile에 다양값을 플러그인 하러간 하드코딩 하지 않아도
빌드할 때 다른 값을 넣을 수 있는 인수

빌드 인수는 코드상에서는 사용불가
dockerFile에서 사용가능, 단 CMD에서는 사용 불가

이미지 빌드 시
docker build ~~ --build-arg [Key] = [value] .
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
docker run -d --rm -p 3000:80 --name feedback-app -v feedback:app/feedback -v "C:\git\docker_study\3.2 data-volumes-07-added-dockerignore:/app:ro" -v /app/node_modules -v /app/temp feedback-node:env